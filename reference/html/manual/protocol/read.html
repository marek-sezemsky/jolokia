<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Jolokia</title>
    <link rel="canonical" href="https://jolokia.org/manual/protocol/read.html">
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/jolokia.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://jolokia.org">Jolokia</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="manual" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Jolokia Manual</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../architecture.html">Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../extensions.html">Extending Jolokia</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../agents.html">Agents</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../proxy_mode.html">Proxy Mode</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../jolokia_protocol.html">Jolokia Protocol</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../jolokia_mbeans.html">Jolokia MBeans</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../clients.html">Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../jolokia_jmx.html">JMX Support</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../spring.html">Spring Support</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Jolokia Manual</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">Jolokia Manual</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
<div class="edit-this-page"><a href="https://github.com/jolokia/jolokia/tree/main/src/documentation/manual/modules/ROOT/pages/protocol/read.adoc">Help improving this page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect2">
<h3 id="read"><a class="anchor" href="#read"></a>Reading attributes (read)</h3>
<div class="paragraph">
<p>Reading MBean attributes is probably the most used JMX method,
especially when it comes to monitoring. Concerning Jolokia, it is
also the most powerful one with the richest semantics. Obviously
the value of a single attribute can be fetched, but Jolokia
supports also fetching of a list of given attributes on a single
MBean or even on multiple MBeans matching a certain pattern.</p>
</div>
<div class="paragraph">
<p>Reading attributes are supported by both kinds of requests,
<code>GET</code> and <code>POST</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Don&#8217;t confuse fetching multiple attributes on possibly multiple
MBeans with bulk requests. A single read request will always
result in a single read response, even when multiple attribute
values are fetched. Only the single response&#8217;s structure of the
<code>value</code> will differ depending on what kind of
read request was performed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A read request for multiple attributes on the same MBean is
initiated by giving a list of attributes to the request. For a
POST request this is an JSON array, for a GET request it is a
comma separated list of attribute names (where slashes and
exclamation marks must be escaped as described in
<a href="../jolokia_protocol.html#escape-rules" class="xref page">Escaping rules</a>). If no attribute is provided, then all
attributes are fetched. The MBean name can be given as a pattern
in which case the attributes are read on all matching MBeans. If a
MBean pattern and multiple attributes are requested, then only the
value of attributes which matches both are returned, the others
are ignored.</p>
</div>
<div class="paragraph">
<p>Paths can be used with pattern and multiple attribute read as well. In order to
skip the extra value levels introduced by a pattern read, the wildcard
<code>*</code> can be used. For example, a read request for the MBean Pattern
<code>java.lang:type=GarbageCollector,*</code> for the Attribute <code>LastGcInfo</code>
returns a complex structure holding information about the last garbage collection. If one is
looking only for the used memory during garbage collection, a path <code>used</code> could be used if
this request wouldn&#8217;t be a pattern request (i.e. refers a specific, single MBean).
But in this case since a
nested map with MBean and Attribute names is returned, the path <code>*/*/*/*/used</code> has to be used
in order to skip the extra levels (for different heaps/spaces) for applying the path.
Note that in the following example the final value is <em>not</em> the full GC-Info but only the
value of its <code>used</code> entry for different spaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"value": {
  "java.lang:name=G1 Young Generation,type=GarbageCollector": {
    "LastGcInfo": {
      "duration": 3,
      "memoryUsageBeforeGc": {
        "CodeHeap 'profiled nmethods'": 4780288,
        "G1 Old Gen": 4934656,
        "CodeHeap 'non-profiled nmethods'": 928256,
        "G1 Survivor Space": 4194304,
        "Compressed Class Space": 1331528,
        "Metaspace": 12812816,
        "G1 Eden Space": 20971520,
        "CodeHeap 'non-nmethods'": 1271296
      },
      "GcThreadCount": 5,
      "startTime": 786,
      "endTime": 789,
      "id": 2,
      "memoryUsageAfterGc": {
        "CodeHeap 'profiled nmethods'": 4780288,
        "G1 Old Gen": 9082880,
        "CodeHeap 'non-profiled nmethods'": 928256,
        "G1 Survivor Space": 2597960,
        "Compressed Class Space": 1331528,
        "Metaspace": 12812816,
        "G1 Eden Space": 0,
        "CodeHeap 'non-nmethods'": 1271296
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following rule of thumb applies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a wildcard is used, everything at that point in the path is
matched. The next path parts are used to match from there
on. All the values on this level are included.</p>
</li>
<li>
<p>Every other path part is literally compared against the values
on that level. If there is a match, this value is
<em>removed</em> in the answer so that at the end
you get back a structure with the values on the wildcard levels
and the leaves of the matched parts.</p>
</li>
<li>
<p>If used with wildcards, paths behave also like
filters. E.g. you can use a path <code>*/*/*/*/used</code> on
the MBean pattern <code>java.lang:*</code> and get back
only that portions which contains "used" as key, all others are
ignored.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="get-read"><a class="anchor" href="#get-read"></a>GET read request</h4>
<div class="paragraph">
<p>The GET URL for a read request has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/read/&lt;mbean name&gt;/&lt;attribute name&gt;/&lt;inner path&gt;</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. GET Read Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Part</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;mbean name&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/ObjectName.html" class="externalLink" target="_blank" rel="noopener">ObjectName</a>
of the MBean for which the attribute should be fetched. It
contains two parts: A domain part and a list of properties
which are separated by <code>:</code>. Properties
themselves are combined in a comma separated list of
key-value pairs. This name can be a pattern in which case
multiple MBeans are queried for the attribute value.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang:type=Memory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;attribute name&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of attribute to read. This can be a list of Attribute
names separated by comma. According to URI compliance, some special characters need to be
escaped as described in
<a href="../jolokia_protocol.html#escape-rules" class="xref page">Escaping rules</a>. If no attribute is given, all
attributes are read.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HeapMemoryUsage</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;inner path&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This optional part describes an <em>inner
path</em> as described in <a href="../jolokia_protocol.html#paths" class="xref page">Paths</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>used</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>With this URL the used heap memory can be obtained:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="post-read"><a class="anchor" href="#post-read"></a>POST read request</h4>
<div class="paragraph">
<p>A the keys available for read POST requests are shown in the
following table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. POST Read Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>read</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mbean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MBean&#8217;s ObjectName which can be a pattern</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang:type=Memory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>attribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attribute name to read or a JSON array containing a list
of attributes to read. No attribute is given, then all attributes
are read.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>HeapMemoryUsage</code></p>
</div>
<div class="paragraph">
<p><code>[ "HeapMemoryUsage", "NonHeapMemoryUsage" ]</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inner path for accessing the value of a complex value
(<a href="../jolokia_protocol.html#paths" class="xref page">Paths</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>used</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following request fetches the number of active threads:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "read",
  "mbean": "java.lang:type=Threading",
  "attribute": "ThreadCount"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="response-read"><a class="anchor" href="#response-read"></a>Read response</h4>
<div class="paragraph">
<p>The general format of the JSON response is described in
<a href="../jolokia_protocol.html#responses" class="xref page">Responses</a> in detail.  A typical response for an
attribute read operation for a GET request with URL like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "java.lang:type=Memory",
    "attribute": "HeapMemoryUsage",
    "type": "read"
  },
  "history": [
    {
      "value": {
        "init": 524288000,
        "committed": 532676608,
        "max": 8334082048,
        "used": 78027104
      },
      "timestamp": 1702454713
    },
    ...
  ],
  "value": {
    "init": 524288000,
    "committed": 532676608,
    "max": 8334082048,
    "used": 86415712
  },
  "status": 200,
  "timestamp": 1702454822
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Since Jolokia 2.1.0 we can use <code>includeRequest</code> parameter to tell Jolokia to exclude <code>request</code> field from the response.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>value</code> contains the response&#8217;s
value. For simple data types it is a scalar value, more complex
types are serialized into a JSON object. See
<a href="../jolokia_protocol.html#serialization" class="xref page">Object serialization</a> for detail on object serialization.</p>
</div>
<div class="paragraph">
<p>For a read request of a single MBean with multiple attributes, the
returned value is a JSON object with the attribute names as keys
and their values as values. For example a request to
<code><a href="http://localhost:8080/jolokia/read/java.lang:type=Memory" class="bare">http://localhost:8080/jolokia/read/java.lang:type=Memory</a></code>
leads to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "java.lang:type=Memory",
    "type": "read"
  },
  "value": {
    "ObjectPendingFinalizationCount": 0,
    "Verbose": false,
    "HeapMemoryUsage": {
      "init": 524288000,
      "committed": 532676608,
      "max": 8334082048,
      "used": 94804320
    },
    "NonHeapMemoryUsage": {
      "init": 7667712,
      "committed": 38928384,
      "max": -1,
      "used": 36905512
    },
    "ObjectName": {
      "objectName": "java.lang:type=Memory"
    }
  },
  "status": 200,
  "timestamp": 1702454894
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A request to a MBean pattern returns as value a JSON object,
with the MBean names as keys and as value another JSON object
with the attribute name as keys and the attribute values as
values. For example a request
<code><a href="http://localhost:8080/jolokia/read/java.lang:type=*/HeapMemoryUsage" class="bare">http://localhost:8080/jolokia/read/java.lang:type=*/HeapMemoryUsage</a></code>
returns something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "java.lang:type=*",
    "attribute": "HeapMemoryUsage",
    "type": "read"
  },
  "value": {
    "java.lang:type=Memory": {
      "HeapMemoryUsage": {
        "init": 524288000,
        "committed": 532676608,
        "max": 8334082048,
        "used": 103192928
      }
    }
  },
  "status": 200,
  "timestamp": 1702454978
}</code></pre>
</div>
</div>
</div>
</div>
</article>
  </div>
<footer class="footer">
  This page was built using the Antora default UI. The source code for this UI is licensed under the terms of the MPL-2.0 license. | Copyright © 2010 -
  2023 Roland Huß
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
</main>
</div>
  </body>
</html>
